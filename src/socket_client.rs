#![warn(unused_variables)]

use goxoy_address_parser::address_parser::*;
use message_io::{network::{Transport, NetEvent, Endpoint}, node::{self, NodeEvent, NodeHandler, NodeListener}};
use std::{
    io::{Read, Write},
    net::TcpStream,
    time::{Duration, Instant}, thread,
};


enum Signal {
    Greet,
    // Any other app event here.
}

pub enum SocketClientErrorType {
    Connection,
    Communication,
}
pub enum SocketConnectionStatus {
    Connected,
    Disconnected,
}
pub struct SocketClient {
    defined: bool,
    handler:Option<NodeHandler<Signal>>,
    server:Option<Endpoint>,
    local_addr: String,
    fn_received: Option<fn(Vec<u8>)>,
    fn_error: Option<fn(SocketClientErrorType)>,
    fn_status: Option<fn(SocketConnectionStatus)>,
}

impl SocketClient {
    pub fn new() -> Self {
        SocketClient {
            defined: false,
            handler:None,
            server:None,
            local_addr: String::new(),
            fn_error: None,
            fn_received: None,
            fn_status: None,
        }
    }
    pub fn new_with_config(config: AddressParser) -> Self {
        SocketClient {
            defined: true,
            handler:None,
            server:None,
            local_addr: AddressParser::object_to_string(config),
            fn_error: None,
            fn_received: None,
            fn_status: None,
        }
    }
    pub fn on_received(&mut self, on_received_callback: fn(Vec<u8>)) {
        self.fn_received = Some(on_received_callback);
    }
    pub fn on_connection_status(&mut self, on_connection_status: fn(SocketConnectionStatus)) {
        self.fn_status = Some(on_connection_status);
    }
    pub fn on_error(&mut self, on_error_callback: fn(SocketClientErrorType)) {
        self.fn_error = Some(on_error_callback);
    }
    pub fn connect_with_config(&mut self, config: AddressParser) -> bool {
        let local_addr = AddressParser::object_to_string(config);
        self.local_addr = local_addr;
        self.defined = true;
        self.connect_sub_fn()
    }
    pub fn connect(&mut self) -> bool {
        if self.defined == false {
            false
        } else {
            /*
            thread::spawn(||{
            });
            */
            self.connect_sub_fn();
            return true;
        }
    }
    fn connect_sub_fn(&mut self) -> bool {
        let addr_obj = AddressParser::string_to_object(self.local_addr.clone());
        let mut local_addr = String::from(addr_obj.ip_address);
        local_addr.push_str(":");
        local_addr.push_str(&addr_obj.port_no.to_string());

        let (handler, listener) = node::split();
        let mut proto_type=Transport::FramedTcp;
        match addr_obj.protocol_type{
            ProtocolType::TCP => proto_type=Transport::FramedTcp,
            ProtocolType::UDP => proto_type=Transport::Udp,
            ProtocolType::WEBSOCKET => proto_type=Transport::Ws,
        }
        let (server, _) = handler.network().connect(proto_type, local_addr).unwrap();
        self.handler=Some(handler.clone());
        self.server=Some(server.clone());
        println!("basladi -> listener.for_each");
        listener.for_each(move |event| match event {
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(_endpoint, _ok) => {
                    if self.fn_status.is_some() {
                        let fn_status_obj = self.fn_status.unwrap();
                        fn_status_obj(SocketConnectionStatus::Connected);
                    }            
                    handler.network().send(server, "omergoksoy!".as_bytes());
                    //handler.signals().send(Signal::Greet)
                },
                NetEvent::Accepted(_, _) => {
                    // Only generated by listening
                }, 
                NetEvent::Message(_endpoint, data) => {
                    if self.fn_received.is_some() {
                        let fn_received_obj = self.fn_received.unwrap();
                        fn_received_obj(data.to_vec());
                    }
                },
                NetEvent::Disconnected(_endpoint) => {
                    if self.fn_error.is_some() {
                        self.fn_error.unwrap()(SocketClientErrorType::Connection);
                    }
                },
            }
            NodeEvent::Signal(signal) => match signal {
                Signal::Greet => { // computed every second
                    handler.network().send(server, "Hello server!".as_bytes());
                    handler.signals().send_with_timer(Signal::Greet, Duration::from_secs(1));
                }
            }
        });
        return true;
    }
    pub fn send(&mut self, data: Vec<u8>) -> bool {
        if self.handler.is_some(){
            let handle=self.handler.as_mut().unwrap();
            handle.network().send(self.server.unwrap(), &data);
        }
        return false;
    }

}

#[test]
fn full_test() {
    // cargo test  --lib full_test -- --nocapture
    let mut client_obj = SocketClient::new_with_config(AddressParser {
        ip_address: "127.0.0.1".to_string(),
        port_no: 1234,
        protocol_type: ProtocolType::TCP,
        ip_version: IPAddressVersion::IpV4,
    });
    client_obj.on_received(|data| {
        println!(
            "Data Received : {}",
            String::from_utf8(data.clone()).unwrap()
        );
    });
    client_obj.on_connection_status(|connection_status| match connection_status {
        SocketConnectionStatus::Connected => {
            println!("Socket Connected");
        }
        SocketConnectionStatus::Disconnected => {
            println!("Socket Disconnected");
        }
    });
    client_obj.on_error(|error_type| match error_type {
        SocketClientErrorType::Connection => {
            println!("Connection Error");
        }
        SocketClientErrorType::Communication => {
            println!("Communication Error");
        }
    });

    let mut since_the_epoch = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .subsec_nanos();
    loop {
        if since_the_epoch >= 1_048_575 {
            since_the_epoch = since_the_epoch / 2;
        } else {
            break;
        }
    }
    if client_obj.connect() {
        let client_id_str = format!("{:0>5}", since_the_epoch.to_string());
        println!("CTRL+C to Exit");
        let mut test_data = String::from("message from => ");
        test_data.push_str(&client_id_str);
        client_obj.send(test_data.as_bytes().to_vec());
        /*
        let mut count = 1;
        loop {
            let result_obj = client_obj.send(test_data.as_bytes().to_vec());
            if result_obj == true {
                println!("Message Sended");
            } else {
                println!("Message Sending Error");
            }
            //client_obj.listen(1500);
            count = count + 1;
            if count > 1_000 {
                break;
            }
        }
        */
        //client_obj.close_connection();
    } else {
        println!("Not Connected To Server");
    }
    assert!(true)
}
